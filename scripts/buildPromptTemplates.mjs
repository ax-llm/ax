#!/usr/bin/env node

import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

function parseArgs(argv) {
  const args = {
    check: false,
    templateDir: undefined,
    output: undefined,
  };

  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];

    if (arg === '--check') {
      args.check = true;
      continue;
    }

    if (arg === '--template-dir') {
      args.templateDir = argv[i + 1];
      i++;
      continue;
    }

    if (arg === '--output') {
      args.output = argv[i + 1];
      i++;
      continue;
    }

    throw new Error(`Unknown argument: ${arg}`);
  }

  return args;
}

function toPosixPath(filePath) {
  return filePath.split(path.sep).join('/');
}

function computeLineAndColumn(content, index) {
  const prefix = content.slice(0, index);
  const lines = prefix.split('\n');
  const line = lines.length;
  const column = (lines.at(-1)?.length ?? 0) + 1;
  return { line, column };
}

function assertInsideRoot(rootDir, filePath, context) {
  const relative = path.relative(rootDir, filePath);

  if (
    relative.startsWith('..') ||
    path.isAbsolute(relative) ||
    relative === ''
  ) {
    throw new Error(
      `Template include escaped root in ${context}: ${toPosixPath(filePath)}`
    );
  }
}

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

async function findMarkdownFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async (entry) => {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        return findMarkdownFiles(fullPath);
      }
      if (entry.isFile() && entry.name.endsWith('.md')) {
        return [fullPath];
      }
      return [];
    })
  );

  return files.flat();
}

function isEntryTemplate(templateDir, filePath) {
  const relative = path.relative(templateDir, filePath);
  const parts = relative.split(path.sep);
  const baseName = path.basename(filePath);

  if (parts.includes('partials')) return false;
  if (baseName.startsWith('_')) return false;

  return true;
}

async function resolveIncludes({
  filePath,
  templateDir,
  stack,
  memo,
  sourceMeta,
}) {
  const normalizedPath = path.resolve(filePath);

  const cycleAt = stack.indexOf(normalizedPath);
  if (cycleAt >= 0) {
    const cycleChain = [...stack.slice(cycleAt), normalizedPath]
      .map((p) => toPosixPath(path.relative(templateDir, p)))
      .join(' -> ');
    throw new Error(`Include cycle detected: ${cycleChain}`);
  }

  const memoized = memo.get(normalizedPath);
  if (memoized) {
    return memoized;
  }

  const content = await fs.readFile(normalizedPath, 'utf8');
  const nextStack = [...stack, normalizedPath];
  const dependencies = new Set([normalizedPath]);

  let lastIndex = 0;
  let output = '';

  const includePattern = /{{\s*include\s+"([^"]+)"\s*}}/g;
  let match = includePattern.exec(content);

  while (match) {
    const [raw, includeRef] = match;
    const includeStart = match.index;

    output += content.slice(lastIndex, includeStart);

    const includePath = path.resolve(path.dirname(normalizedPath), includeRef);
    const { line, column } = computeLineAndColumn(content, includeStart);

    assertInsideRoot(
      templateDir,
      includePath,
      `${toPosixPath(path.relative(templateDir, normalizedPath))}:${line}:${column}`
    );

    if (!(await fileExists(includePath))) {
      throw new Error(
        `Missing include '${includeRef}' in ${toPosixPath(
          path.relative(templateDir, normalizedPath)
        )}:${line}:${column}`
      );
    }

    const resolvedInclude = await resolveIncludes({
      filePath: includePath,
      templateDir,
      stack: nextStack,
      memo,
      sourceMeta,
    });

    for (const dep of resolvedInclude.dependencies) {
      dependencies.add(dep);
    }

    output += resolvedInclude.content;
    lastIndex = includeStart + raw.length;

    match = includePattern.exec(content);
  }

  output += content.slice(lastIndex);

  sourceMeta.set(normalizedPath, content);

  const resolved = {
    content: output,
    dependencies,
  };

  memo.set(normalizedPath, resolved);
  return resolved;
}

function generateTypeScript({ templates, sources }) {
  const quote = (value) => {
    const json = JSON.stringify(value);
    const inner = json.slice(1, -1).replace(/'/g, "\\'");
    return `'${inner}'`;
  };

  const lines = [
    '/* eslint-disable */',
    '// Auto-generated by scripts/buildPromptTemplates.mjs. Do not edit.',
    '',
    '// biome-ignore format: generated file',
    'export const promptTemplates = {',
  ];

  for (const [id, content] of templates) {
    lines.push(`  ${quote(id)}: ${quote(content)},`);
  }

  lines.push('} as const;');
  lines.push('');
  lines.push('export type TemplateId = keyof typeof promptTemplates;');
  lines.push('');
  lines.push('// biome-ignore format: generated file');
  lines.push(
    'export const promptTemplateSources: Record<TemplateId, readonly string[]> = {'
  );

  for (const [id, files] of sources) {
    if (files.length <= 1) {
      const only = files[0];
      lines.push(
        `  ${quote(id)}: [${only ? quote(only) : ''}],`
      );
      continue;
    }

    lines.push(`  ${quote(id)}: [`);
    for (const file of files) {
      lines.push(`    ${quote(file)},`);
    }
    lines.push('  ],');
  }

  lines.push('};');
  lines.push('');

  return `${lines.join('\n')}`;
}

export async function compilePromptTemplates(options = {}) {
  const scriptDir = path.dirname(fileURLToPath(import.meta.url));
  const repoRoot = path.resolve(scriptDir, '..');
  const templateDir = path.resolve(
    options.templateDir ?? path.join(repoRoot, 'src/ax/prompts/templates')
  );
  const outputFile = path.resolve(
    options.output ?? path.join(repoRoot, 'src/ax/prompts/templates.generated.ts')
  );
  const check = Boolean(options.check);

  if (!(await fileExists(templateDir))) {
    throw new Error(`Template directory not found: ${templateDir}`);
  }

  const allFiles = (await findMarkdownFiles(templateDir)).sort((a, b) =>
    a.localeCompare(b)
  );

  const entryFiles = allFiles.filter((filePath) =>
    isEntryTemplate(templateDir, filePath)
  );

  const memo = new Map();
  const sourceMeta = new Map();
  const templates = [];
  const sources = [];

  for (const entryFile of entryFiles) {
    const resolved = await resolveIncludes({
      filePath: entryFile,
      templateDir,
      stack: [],
      memo,
      sourceMeta,
    });

    const templateId = toPosixPath(path.relative(templateDir, entryFile));
    const dependencyFiles = [...resolved.dependencies]
      .map((dep) => toPosixPath(path.relative(templateDir, dep)))
      .sort((a, b) => a.localeCompare(b));

    templates.push([templateId, resolved.content]);
    sources.push([templateId, dependencyFiles]);
  }

  templates.sort((a, b) => a[0].localeCompare(b[0]));
  sources.sort((a, b) => a[0].localeCompare(b[0]));

  const generated = generateTypeScript({ templates, sources });

  if (check) {
    const existing = (await fileExists(outputFile))
      ? await fs.readFile(outputFile, 'utf8')
      : null;

    if (existing !== generated) {
      throw new Error(
        `Template output is stale: ${toPosixPath(path.relative(repoRoot, outputFile))}`
      );
    }
    return { written: false, checked: true, outputFile };
  }

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, generated, 'utf8');

  return { written: true, checked: false, outputFile };
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const result = await compilePromptTemplates(args);

  if (result.checked) {
    console.log('Prompt templates are up to date.');
    return;
  }

  console.log(`Generated prompt templates: ${result.outputFile}`);
}

const isMain =
  process.argv[1] &&
  path.resolve(process.argv[1]) === fileURLToPath(import.meta.url);

if (isMain) {
  main().catch((error) => {
    console.error(error.message || error);
    process.exitCode = 1;
  });
}
